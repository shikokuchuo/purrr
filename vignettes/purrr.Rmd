---
title: "Get started with purrr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started with purrr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

purrr helps you write cleaner, more maintainable R code through functional programming concepts. But what is functional programming? At its core, it's an approach to programming that emphasizes using functions to transform data, similar to how you might use a series of tools to process raw materials into a final product. 
Instead of writing loops and modifying data step by step, functional programming encourages you to think about your data transformations as a series of function applications. This is rather abstract, but we believe that helps to makes your code clearer and less prone to errors.

This vignette discusses two of the most important parts of purrr: map functions and predicate functions.

```{r}
library(purrr)
```

## Map: A better way to loop

`map()` provides a more compact way apply functions to each element of a vector:

```{r}
x <- 1:3

triple <- function(x) x * 3
out <- map(x, triple)
str(out)
```

Or written with the pipe:

```{r}
x |> 
  map(triple) |> 
  str()
```

This is equivalent to a for loop:

```{r}
out <- vector("list", 3)
for (i in seq_along(x)) {
  out[[i]] <- triple(x[[i]])
}
str(out)
```

(You might wonder why this function is called `map()`. What does it have to do with depicting physical features of land or sea 🗺? In fact, the meaning comes from mathematics where map refers to “an operation that associates each element of a given set with one or more elements of a second set”. This makes sense here because `map()` defines a mapping from one vector to another. And "map" also has the nice property of being short, which is useful for such a fundamental building block.)

There are some benefits to `map()` in isolation: once you get used to the syntax, it's a very compact way to express the idea of iterating over a vector, returning one output element for each input element. But there are a number of other reasons to use `map()`, which we'll explore in the following sections:

* Progress bars
* Parallel computing
* Output variants
* Input variants

### Progress bars

For long-running jobs, it's really useful to get a progress bar, which gives you an estimate of how long you have to wait. These are easy to enable in purrr: just set `.progress = TRUE`. It's hard to illustrate progress bars in a vignette, but you can try it out interactively with this example:

```{r}
#| eval: false
out <- map(1:100, \(i) Sys.sleep(0.5), .progress = TRUE)
```

Learn more about progress bars in `?progress_bars`

### Parallel computing

By default, `map()` runs only in your current R session. But you can easily opt-in to spreading your task across multiple R sessions, and hence multiple cores with `in_parallel()`. purrr's parallelism is powered by mirai, so to begin, you need to start up a number of background R sessions, called daemons:

```{r}
mirai::daemons(6)
```

(You only need to do this once per session)

Now you can easily convert your `map()` call to run in parallel:

```{r}
out <- map(1:5, in_parallel(\(i) Sys.sleep(0.5)))
```

It's important to realise that this parallelism works by spreading computation across clean R sessions. That means that code like this will not work, because the worked daemons won't have a copy of `my_lm()`:

```{r}
#| error: true
my_lm <- function(formula, data) {
  Sys.sleep(0.5)
  lm(formula, data)
}
by_cyl <- split(mtcars, mtcars$cyl)
out <- map(by_cyl, in_parallel(\(df) my_lm(mpg ~ disp, data = df)))
```

You can resolve this by ensuring that your functions are self-contained, or pass any additional data in `in_parallel()`:

```{r}
out <- map(by_cyl, in_parallel(\(df) my_lm(mpg ~ disp, data = df), my_lm = my_lm))
```

For more complicated situations, you might want to save the object returned by `in_parallel()` as it's own object:

```{r}
self_contained_lm <- in_parallel(
  \(df) my_lm(mpg ~ disp, data = df), 
  my_lm = my_lm
)
self_contained_lm(mtcars)

out <- map(by_cyl, self_contained_lm)
```

Learn more about parallel computing in `?in_parallel`.

### Output variants

purrr functions are type-stable, which means it's easy to predict what type of output they return, e.g. `map()` always returns a list. But what if you want a different type of output? That's where the output variants come to play:

* There are four variants for the four most important types of atomic vector:
  * `map_lgl()` returns a logical vector.
  * `map_int()` returns an integer vector.
  * `map_dbl()` returns a numeric (double) vector.
  * `map_chr()` returns a character vector.

* For all other types of vector (like dates, date-times, factors, etc) there's `map_vec()`. It's a little harder to precisely describe the output type, but if your function returns length-1 vector of type "foo", then the output of `map_vec()` will be a length-n vector of type "foo".

* `modify()` returns output with the same type as the input. For example, if the input is a data frame, the output will also be a data frame.

* `walk()` returns the input (invisibly); it's useful when you calling a function purely for its side-effects, for example generating plots or saving files.

It's often natural to string together multiple map variants using the pipe. For example, the following code splits `mtcars` into one data frame for each value of `cyl`, fits a linear model to each subset, computes the model summary, and then extracts the R-squared:

```{r}
mtcars |> 
  split(mtcars$cyl) |> # from base R
  map(\(df) lm(mpg ~ wt, data = df)) |> 
  map(summary) |>
  map_dbl(\(x) x$r.squared)
```

### Input variants

`map()` and friends all iterate over a single list, `.x`. This means it only varies `.x` when calling `.f`, and all other arguments are passed along unchanged, thus making it poorly suited for some problems. For example, how would you find a weighted mean when you have a list of observations and a list of weights? Imagine we have the following data:

```{r}
xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)
```

We could use `map_dbl()` to compute unweighted means:

```{r}
map_dbl(xs, mean)
```

But there's no way to compute a weighted mean because we need to call `weighted.mean(xs[[1]], ws[[1]])`, `weighted.mean(xs[[2]], ws[[2]])` etc. That's the job of `map2()`:

```{r}
map2_dbl(xs, ws, weighted.mean)
```

Note that the arguments that vary for each call come before the function, arguments that are constant come after the function: 

```{r}
map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
```

But we generally recommend using an anonymous function instead:

```{r}
#| eval: false
map2_dbl(xs, ws, \(x, w) weighted.mean(x, w, na.rm = TRUE))
```

There are two important variants of `map2()`: `pmap()` which can take any number of varying arguments (passed as a list), and `imap()` which iterates over the values and indices of a single vector. Learn more in their documentation.

### Combinatorial explosion

What makes purrr particularly special is all of the above features (progress bars, parallel computing, output variants and input variants) can be combined any way that you choose. The combination of inputs (prefixs) and outputs (suffixes) forms a matrix, and you can use `.progress` or `in_parallel()` with any of them:

| Output type | Single input (.x) | Two inputs (.x, .y) | Multiple inputs (...) |
|-------------|-------------------|---------------------|----------------------|
| **List** | `map(.x, .f)` | `map2(.x, .y, .f)` | `pmap(.l, .f)` |
| **Logical** | `map_lgl(.x, .f)` | `map2_lgl(.x, .y, .f)` | `pmap_lgl(.l, .f)` |
| **Integer** | `map_int(.x, .f)` | `map2_int(.x, .y, .f)` | `pmap_int(.l, .f)` |
| **Double** | `map_dbl(.x, .f)` | `map2_dbl(.x, .y, .f)` | `pmap_dbl(.l, .f)` |
| **Character** | `map_chr(.x, .f)` | `map2_chr(.x, .y, .f)` | `pmap_chr(.l, .f)` |
| **Input** | `walk(.x, .f)` | `walk2(.x, .y, .f)` | `pwalk(.l, .f)` |

## Filtering and finding with predicates

purrr provides a number of functions that work with predicate functions. Predicate functions take a vector and return either `TRUE` or `FALSE`, with examples including `is.character()` and `\(x) any(is.na(x))`. You typically use them to filter or find, and purrr comes with a bunch of helpers to make them easier to use:

* `detect(.x, .p)` returns the value of the first element in `.x` where `.p` is `TRUE`.
* `detect_index(.x, .p)` returns the position of the first element in `.x` where `.p` is `TRUE`.
* `keep(.x, .p)` returns all elements from `.x` where `.p` evaluates to `TRUE`
* `discard(.x, .p)` returns all elements from `.x` where `.p` evaluates to `FALSE`
* `every(.x, .p)` returns `TRUE` if `.p` returns `TRUE` for every element in `.x`
* `some(.x, .p)` returns `TRUE` if `.p` returns `TRUE` for at least one element in `.x`  
* `none(.x, .p)` returns `TRUE` if `.p` returns `FALSE` for all elements in `.x`
* `head_while(.x, .p)` returns elements from the beginning of `.x` while `.p` is `TRUE`, stopping at the first `FALSE`
* `tail_while(.x, .p)` returns elements from the end of `.x` while `.p` is `TRUE`, stopping at the first `FALSE`

You'll typically use these functions with lists, since you can usually rely on vectorisation for simpler vectors.

```{r}
x <- list(
  a = letters[1:10],
  b = 1:10,
  c = runif(15)
)

x |> detect(is.character)
x |> detect_index(is.numeric)

x |> keep(is.numeric) |> str()
x |> discard(is.numeric) |> str()

x |> every(\(x) length(x) > 10)
x |> some(\(x) length(x) > 10)
x |> none(\(x) length(x) == 0)
```
